실행방법에 따른 자바 클래스의 구분
  - Application : main메소드를 만들어서 실행
    java 클래스명
         ------
           |___ java인터프리터가 public static void main(String[] args)스펙의 메소드를
                찾아서 실행
                
  - Applet : html태그로 삽입(지금은 안쓴다. - 무겁다)
  - Servlet 
  
<<서블릿>>
  - 클라이언트의 요청을 처리하기 위한 자바 기술
  - 서버에서 클라이언트의 요청을 처리하고 응답할 수 있도록 만들어진 객체
  - 클라이언트가 요청하면 서버에서 실행되면서 DB에 대한 처리, 서버의 리소스를 이용해서 만들어진 결과를  클라이언트에 응답
  - 클라이언트가 요청하면 서버가 요청한 서블릿을 찾아서 실행하므로 서버가 찾을 수 있는 위치에 있어야 한다.
                                                    --------------------------
                                                     서블릿디렉토리(classes)
                                                     표준화된 폴더 구조의 classes폴더
                                                     => 서버가 서블릿을 찾는 위치
  - 서버 내부에 구성된 많은 기능들을 우리가 만들어 놓은 서블릿 클래스에서 실행되도록 하려면 서버가 서블릿이라고 인지할 수 있어야
    한다. 서블릿이 되기 위한 규칙이 존재
    규칙에 맞게 서블릿을 작성해야 한다.

1. 서블릿작성규칙
   - 서버가 찾아서 실행할 수 있도록 규칙에 맞게 서블릿을 작성해야 한다.
   1) 표준화된 폴더 구조 안에 서블릿클래스가 위치해야 한다.
      서블릿이 저장될 폴더(서블릿디렉토리) - classes
      [표준화된 폴더 구조]
       context
          |
          |----- jsp, html,css,js,image....(폴더에 있어도 된다.)
          |_____ WEB-INF
                    |----web.xml : 설정정보
                    |----lib(폴더) : 자바라이브러리 파일
                    |___ classes(폴더) : 서블릿, dao, dto, vo, service ...자바클래스
                    
    2) 서버에서 호출될 것이므로 무조건 public클래스로 작성해야 한다.
    3) 서버가 서블릿으로 인식하고 실행해야 하므로 무조건 상속해야 하는 클래스가 존재한다.
       => 서블릿클래스가 되기 위해서 무조건 서블릿클래스를 상속해야 한다.
          Servlet         인터페이스
            ^
            |
       GenericServlet     추상클래스(서블릿의 일반적인 내용이 정의된 서블릿클래스)
            ^
            |
       HttpServlet        http(https)프로토콜에 특징적인 내용이 정의된 서블릿클래스
            ^              ------------------------------
            |                         |___ 쿠키, 세션.....            
            |
        MyServlet         사용자가 만든 서블릿              

    4) 서버가 호출할 메소드를 오버라이딩
       - 사용자가 임의로 메소드를 만들면 서버가 알 수 없다.
       - 서버가 자동으로 찾아서 호출하기 위해서 상속받는 클래스의 메소드를 오버라이딩해서 내가 실행하고 싶은 명령문을 구현한다.
       - 서버가 적절한 시점에 호출하는 메소드를 callback메소드라 한다.
       - 클라이언트가 요청하면 서버가 요청을 분석해서 서블릿디렉토리에 위치한 서블릿을 찾아서 적절한 시점에 오버라이딩된 메소드를
         자동으로 호출
         따라서 상황에 맞게 실행하고 싶은 내용이 있는 경우 메소드를 오버라이딩해서 내용을 정의해야 한다.
       - 자동으로 메소드가 호출된다는 의미는 자동으로 객체가 생성된다는 의미
         즉, 객체의 lifecycle을 서버가 관리한다는 의미
                  ----------
                     |__ 객체가 생성되고 객체를 사용하고 객체를 메모리에서 해제하기 까지의 모든 작업을 서버가 알아서 관리
                     
       - 오버라이딩해야 하는 메소드가 lifecycle과 관련있는 메소드
       
       [오버라이딩해야 하는 메소드]
       - init : 서블릿객체가 초기화될때 호출
       - service : 클라이언트가 요청할때 호출
                   => 클라이언트의 요청을 처리하는 메소드로 요청을 받고 처리할 내용을 구현
                   ex) 로그인, 로그아웃, 회원가입, 게시판목록보기, 장바구니, 예약하기, 예약조회......
       - destroy : 서블릿객체가 메모리에서 해제될때
   5) 서블릿등록
      - 서버가 서블릿을 찾을 수 있도록 등록
      - 서버가 요청정보를 분석해서 서블릿디렉토리에서 서블릿을 찾아서 실행할 수 있도록 어떤 요청에 대해서 어떤 서블릿이 실행
        될지를 등록
      - 설정파일(web.xml)에 등록
      - 실제작업은 annotation으로 설정
      - web.xml파일은 xml형식의 파일이므로 사용할 엘리먼트가 이미 정의되어 있고 작성규칙이 정해져 있으므로 
        맞게 작업해야 한다.                                          ----------
                                                                   dtd - xml안에 정의하고 사용할 엘리먼트에
                                                                         대한 명세를 정의
                                                                         (엘리먼트의 순서, 타입, 값,하위구조..)
        ⓘ 서블릿을 등록
           - 실제 어떤 패키지의 어떤 클래스를 실행할 것인지 등록 : 무엇을
            <servlet>
  				<servlet-name>서블릿명(alias)</servlet-name>
  				<servlet-class>서블릿의 실제 클래스명과 위치(패키지명)</servlet-class>
  			</servlet>
  			ex) basic패키지에 FirstServlet을 first이름으로 등록
  			<servlet>
  				<servlet-name>first</servlet-name>
  				<servlet-class>basic.FirstServlet</servlet-class>
  			</servlet>
  			
        ② 서블릿매핑
           - 등록된 서블릿을 어떻게 요청하면 실행할 것인지 등록(어떤 url로 요청할 것인지)
           - 반드시 <servlet>엘리먼트 다음에 정의해야 한다. 
           - <servlet>엘리먼트와 한 쌍으로 정의해야 한다.
           - 먼저 등록한 서블릿을 어떻게 요청할 것인지 등록하기 위한 엘리먼트
           <servlet-mapping>
  				<servlet-name>위에서 정의한 서블릿의 이름</servlet-name>
  				<url-pattern>요청할 서블릿의 path</url-pattern>
  				            -------------------
 		   </servlet-mapping>     ^
                                  |__ 반드시 /나 .으로 시작
           ex) first라는 이름으로 등록된 서블릿을 /first.playdata로 요청하면 실행되도록 정의
           <servlet-mapping>
  				<servlet-name>first</servlet-name>
  				<url-pattern>/first.playdata</url-pattern>
  		   </servlet-mapping>   
                                                                        
2. 서블릿요청방법
   - 서블릿을 어떻게 실행해야 하는지 알 수 있어야 한다.
   - html문서에서 요청
     http://서버ip:port/context명/서블릿매핑명
                               ------------
                               |__web.xml에 <url-pattern>에 등록하거나 annotation으로 등록한 path
                                                                                                                
     http://192.168.0.114:8088/serverweb/gugudan.html
     ----  ----------    ----- --------- ---------------
     프로토콜  ip           port  context명    매핑명

   - 서블릿을 못찾는 경우 - 404응답코드
   - 서블릿은 요청방법에 따라서 get방식과 post방식으로 요청할 수 있다.
   -  HttpServlet에서 제공되는 doGet이나 doPost메소드를 오버라이딩
                            ------   -------
                            get방식    post방식
   1) get방식으로 요청
      => 클라이언트가 입력한 내용이 요청헤더에 저장되어 서버로 전송되는 방식
         주로 서버의 데이터를 가져오는 경우 사용
         
      ① 주소표시줄에 직접 입력해서 요청하는 방식
        => 테스트용으로 사용되거나 첫 번째 페이지에서 요청되는 경우     
      ② 하이퍼링크로 클릭
        <a href="/context명/서블릿요청path(매핑명)">구구단요청하기</a>
   
      ③ <form>태그 method속성에 get을 정의하고 submit버튼을 눌러 요청하는 경우
       => <form>태그의 submit버튼을 누르면 action속성에 정의한 application이 실행되면서
          <form></form>사이에 정의된 모든 양식태그의 name=value가 전송된다.
                           ----------------------------------
                                 사용자가 선택하거나 입력한 값
       => method속성을 생략하면 get방식
       
       <form method="요청방식" action="요청해서 실행할 web application의 path">
       </form>
       
   2) post방식으로 요청
      <form>태그 method속성에 post를 정의하고 submit버튼을 눌러 요청하는 경우
       <form method="post" action="요청해서 실행할 web application의 path">
       </form>
   
   3) 자바스크립트로 요청
      ① location.href에 연결하기
        => get방식으로 요청

3. 서블릿의 lifecycle
   - 서블릿객체는 최초 요청될 때 한 개가 생성
   - 쓰레드가 생성되면서 실행
   - init : 객체가 생성되고 초기화될때 호출
   - service : 클라이언트가 요청하면 호출(요청방식과 상관없이 실행)
               service를 오버라이딩하지 않으면 get방식으로 요청하면 doGet이 실행
               post방식으로 요청하면 doPost실행
               
   - doGet : 클라이언트가 get방식으로 요청
   - doPost : 클라이언트가 post방식으로 요청
   - destroy : 서블릿객체가 소멸
   
   ==> 요청방식에 따라서 실행되는 메소드명, 매개변수순서, 매개변수타입이 다르면 405번 응답코드
   
4. 서블릿요청정보 추출
   => <form></form>사이에 정의된 양식태그를 통해서 서버에 전송하는 데이터를 추출
    ---------------------------------------
         사용자가 선택하거나 입력한 값 = 파라미터
         파라미터는 name과 value가 전송
    - 요청객체에서 제공되는 메소드를 이용해서 추출
      -------
           ServletRequest
               ^
               |
        HttpServletRequest
    - 클라이언트가 입력한 내용을 String으로 반환
    - 클라이언트가 입력한 name과 value를 한 쌍으로 저장해야 하므로 ServletRequest객체의 내부에는 Map의 형태로 
      이 요청정보를 저장할 수 있도록 저장소가 제공된다.
      String value =  req.getParameter("파라미터명")
      String[] values = req.getParameterValues("파라미터명") ---> 동일한 이름으로 작성된 파라미터가 모두 추출
      
5. 비지니스메소드 호출
   -> 서블릿에서 비지니스로직을 분리한다.
   
6. DB연동
   JDBC -> Spring JDBC -> Mybatis -> JPA
   1) 테이블관리
   2) 제약조건
   3) JDBC
   
               
   
   
   
   
   
   
   
   
   
       
   
   
   
   
   
   
   
    







    
    
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  